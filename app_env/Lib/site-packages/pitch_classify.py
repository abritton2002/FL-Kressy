import pandas as pd
import numpy as np
import math
import logging
from sqlalchemy import create_engine, pool, text
import threading
import time
from functools import lru_cache

# Logging Configuration - Reduced logging for performance
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.FileHandler('pitch_design.log'), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Database Connection with optimized connection pool
DB_CONFIG = {
    'host': '10.200.200.107',
    'user': 'readonlyuser',
    'password': 'pKufhAALb7r9Z0x',
    'database': 'statcast_db'
}
engine = create_engine(
    f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}/{DB_CONFIG['database']}?charset=utf8mb4",
    poolclass=pool.QueuePool,
    pool_size=20,  # Increased pool size
    max_overflow=10,
    pool_pre_ping=True,  # Check connection validity before using
    pool_recycle=3600    # Recycle connections after 1 hour
)

# Pitch Type Mapping
PITCH_TYPE_MAP = {
    "SV": "Slurve", "ST": "Sweeper", "SL": "Slider", 
    "CH": "Changeup", "CU": "Curveball", "FC": "Cutter", 
    "SI": "Sinker", "FF": "Four-Seam Fastball"
}

# Cache for fastball matches to reduce duplicate database calls
@lru_cache(maxsize=32)
def get_fastball_matches(
    pitch_hand, velocity_min, velocity_max, spin_min, spin_max, 
    h_break_min, h_break_max, v_break_min, v_break_max,
    release_x_min, release_x_max, release_z_min, release_z_max,
    spin_eff_min, spin_eff_max
):
    """Cache fastball matches to avoid redundant queries"""
    # Using a simplified query with denormalized params for cache key stability
    params = (
        pitch_hand, round(velocity_min), round(velocity_max), 
        round(spin_min), round(spin_max), 
        round(h_break_min), round(h_break_max), 
        round(v_break_min), round(v_break_max),
        round(release_x_min, 1), round(release_x_max, 1),
        round(release_z_min, 1), round(release_z_max, 1),
        round(spin_eff_min), round(spin_eff_max)
    )
    
    fastball_query = text("""
    SELECT DISTINCT sc_raw.pitcher
    FROM sc_raw
    JOIN dl_pitching ON sc_raw.pitch_id_raw = dl_pitching.pitch_id_dl_pitch
    WHERE sc_raw.pitch_type = 'FF'
      AND sc_raw.p_throws = :p_throws
      AND sc_raw.release_speed BETWEEN :vel_min AND :vel_max
      AND sc_raw.release_spin_rate BETWEEN :spin_min AND :spin_max
      AND (sc_raw.pfx_x * -12) BETWEEN :h_min AND :h_max
      AND (sc_raw.pfx_z * 12) BETWEEN :v_min AND :v_max
      AND sc_raw.release_pos_x BETWEEN :x_min AND :x_max
      AND sc_raw.release_pos_z BETWEEN :z_min AND :z_max
      AND dl_pitching.spin_eff_release_est2 BETWEEN :eff_min AND :eff_max
      AND sc_raw.release_speed IS NOT NULL
      AND sc_raw.release_spin_rate IS NOT NULL
      AND sc_raw.pfx_x IS NOT NULL
      AND sc_raw.pfx_z IS NOT NULL
    LIMIT 300
    """)
    
    start_time = time.time()
    bind_params = {
        'p_throws': pitch_hand,
        'vel_min': velocity_min, 'vel_max': velocity_max,
        'spin_min': spin_min, 'spin_max': spin_max,
        'h_min': h_break_min, 'h_max': h_break_max,
        'v_min': v_break_min, 'v_max': v_break_max,
        'x_min': release_x_min, 'x_max': release_x_max,
        'z_min': release_z_min, 'z_max': release_z_max,
        'eff_min': spin_eff_min, 'eff_max': spin_eff_max
    }
    
    with engine.connect() as conn:
        result = conn.execute(fastball_query, bind_params)
        pitchers = [row[0] for row in result]
    
    logger.info(f"Fastball query found {len(pitchers)} pitchers in {time.time() - start_time:.2f} seconds")
    return pitchers

def recommend_secondary_pitches(
    pitch_hand: str, 
    velocity: float, 
    spin_rate: float,
    trackman_h_break: float, 
    v_break: float, 
    release_x_ft: float, 
    release_z_ft: float,
    spin_efficiency: float
) -> pd.DataFrame:
    """
    Recommend up to 3 secondary pitch profiles (2 breaking, 1 other), excluding FS, with ±25% fastball profile.
    Optimized for performance.
    """
    start_time = time.time()
    
    # Adjust release_x for Statcast (positive right from catcher's view)
    statcast_release_x = -release_x_ft if pitch_hand == 'R' else release_x_ft
    
    # Fastball constraints (±25% except velocity ±2 MPH, spin ±200 RPM, spin efficiency ±3%)
    velocity_min = velocity - 2
    velocity_max = velocity + 2
    spin_rate_min = spin_rate - 200
    spin_rate_max = spin_rate + 200
    spin_eff_min = max(0, spin_efficiency - 3)
    spin_eff_max = min(100, spin_efficiency + 3)
    h_break_range = abs(trackman_h_break) * 0.25
    h_break_min = trackman_h_break - h_break_range
    h_break_max = trackman_h_break + h_break_range
    v_break_range = abs(v_break) * 0.25
    v_break_min = v_break - v_break_range
    v_break_max = v_break + v_break_range
    release_x_range = .1
    release_x_min = statcast_release_x - release_x_range
    release_x_max = statcast_release_x + release_x_range
    release_z_range = .1
    release_z_min = release_z_ft - release_z_range
    release_z_max = release_z_ft + release_z_range

    try:
        # Get matching fastball pitchers using cached function
        pitchers = get_fastball_matches(
            pitch_hand, velocity_min, velocity_max, spin_rate_min, spin_rate_max,
            h_break_min, h_break_max, v_break_min, v_break_max, 
            release_x_min, release_x_max, release_z_min, release_z_max,
            spin_eff_min, spin_eff_max
        )
        
        if not pitchers:
            logger.info("No fastball pitchers matched the profile.")
            return pd.DataFrame()
        
        # Convert the pitcher list to a comma-separated string for the IN clause
        pitcher_ids_str = ','.join(str(pid) for pid in pitchers)
        
        # Performance-optimized secondary pitch query with explicit IN clause
        secondary_query = f"""
        SELECT 
            dm.manual_pitch_type_cons AS pitch_type_cons,
            sc_raw.pitch_type,
            COUNT(*) AS pitch_count,
            AVG(sc_raw.release_speed) AS avg_velocity,
            AVG(sc_raw.release_spin_rate) AS avg_spin_rate,
            AVG(-sc_raw.pfx_x * 12) AS avg_h_break,
            AVG(sc_raw.pfx_z * 12) AS avg_v_break,
            AVG(sc_raw.vx0) AS avg_vx0,
            AVG(sc_raw.vy0) AS avg_vy0,
            AVG(sc_raw.vz0) AS avg_vz0,
            AVG(sc_raw.spin_direction_observed) AS avg_spin_direction_observed,
            AVG(dl_pitching.stuff_plus) AS avg_stuff_plus,
            AVG(dl_pitching.spin_eff_release_est2) AS avg_spin_efficiency,
            AVG(dl_pitching.spin_eff_release_est2 / 100.0) AS avg_active_spin,
            sc_raw.p_throws,
            CASE 
                WHEN dm.manual_pitch_type_cons IN ('SL', 'SV', 'CU', 'ST', 'FC') THEN 'Breaking'
                ELSE 'Other'
            END AS pitch_category
        FROM sc_raw
        JOIN dl_pitching ON sc_raw.pitch_id_raw = dl_pitching.pitch_id_dl_pitch
        JOIN dl_misc dm ON sc_raw.pitch_id_raw = dm.pitch_id_dl
        WHERE sc_raw.pitcher IN ({pitcher_ids_str})
          AND sc_raw.pitch_type NOT IN ('FF', 'SI', 'FS')
          AND sc_raw.release_speed IS NOT NULL
          AND sc_raw.release_spin_rate IS NOT NULL
          AND sc_raw.pfx_x IS NOT NULL
          AND sc_raw.pfx_z IS NOT NULL
          AND sc_raw.spin_direction_observed IS NOT NULL
          AND dl_pitching.stuff_plus > 90
        GROUP BY dm.manual_pitch_type_cons, sc_raw.pitch_type, sc_raw.p_throws
        HAVING pitch_count >= 10
        ORDER BY avg_stuff_plus DESC
        LIMIT 30;
        """
        
        # Execute secondary pitch query
        secondary_query_start = time.time()
        pitch_df = pd.read_sql(
            secondary_query,
            engine
        )
        logger.info(f"Secondary pitch query took {time.time() - secondary_query_start:.2f} seconds")
        
        # Log results
        if not pitch_df.empty:
            logger.info(f"Found {len(pitch_df)} potential secondary pitch types")
        else:
            logger.info("No matching secondary pitches found after query.")
            return pd.DataFrame()
        
        # Rank and select with diversity - optimized for speed
        selection_start = time.time()
        breaking_df = pitch_df[pitch_df['pitch_category'] == 'Breaking'].nlargest(2, 'avg_stuff_plus')
        other_df = pitch_df[pitch_df['pitch_category'] == 'Other'].nlargest(1, 'avg_stuff_plus')
        final_df = pd.concat([breaking_df, other_df]).nlargest(3, 'avg_stuff_plus')
        
        if len(final_df) < 3 and len(pitch_df) > len(final_df):
            remaining = 3 - len(final_df)
            additional_df = pitch_df[~pitch_df['pitch_type_cons'].isin(final_df['pitch_type_cons'])].nlargest(remaining, 'avg_stuff_plus')
            final_df = pd.concat([final_df, additional_df]).nlargest(3, 'avg_stuff_plus')
        
        if final_df.empty:
            final_df = pitch_df.nlargest(3, 'avg_stuff_plus')
        
        logger.info(f"Pitch selection took {time.time() - selection_start:.2f} seconds")
        
        # Compute spin components - this is CPU intensive
        spin_start = time.time()
        spin_df = calculate_spin_components_from_averages(final_df)
        logger.info(f"Spin calculation took {time.time() - spin_start:.2f} seconds")
        
        # Join results
        result_df = final_df[[
            'pitch_type_cons', 'pitch_type', 'pitch_count', 'avg_velocity', 'avg_spin_rate',
            'avg_h_break', 'avg_v_break', 'avg_stuff_plus', 'avg_spin_efficiency', 'avg_active_spin'
        ]].join(spin_df[['omega_x', 'omega_y', 'omega_z', 'spin_axis_theta', 'spin_axis_phi']])
        
        logger.info(f"Total recommendation time: {time.time() - start_time:.2f} seconds")
        return result_df
    
    except Exception as e:
        logger.error(f"Error in recommend_secondary_pitches: {e}")
        return pd.DataFrame()

def calculate_spin_components_from_averages(df):
    """Calculate spin components from averaged inputs with null handling. Optimized version."""
    # Pre-compute column renames with a single operation for efficiency
    df = df.rename(columns={
        'avg_vx0': 'vx0',
        'avg_vy0': 'vy0',
        'avg_vz0': 'vz0',
        'avg_spin_rate': 'release_spin_rate',
        'avg_spin_direction_observed': 'spin_direction_observed',
        'avg_active_spin': 'active_spin'
    })
    
    # Handle nulls with fillna for all columns at once
    fill_values = {
        'vx0': 0,
        'vy0': -90,
        'vz0': 0,
        'release_spin_rate': 0,
        'spin_direction_observed': 0,
        'active_spin': 0
    }
    df = df.fillna(fill_values)
    
    # Convert to numpy arrays for faster computation
    vx0 = df['vx0'].to_numpy() * 0.3048
    vy0 = df['vy0'].to_numpy() * 0.3048
    vz0 = df['vz0'].to_numpy() * 0.3048
    
    # Vectorized calculations
    v = np.sqrt(vx0**2 + vy0**2 + vz0**2)
    phi_release = np.arctan2(vx0, vy0)
    theta_release = np.arcsin(vx0 / v)
    
    v_hat_x = np.cos(theta_release) * np.sin(phi_release)
    v_hat_y = np.cos(theta_release) * np.cos(phi_release)
    v_hat_z = np.sin(theta_release)
    
    phi = np.deg2rad(df['spin_direction_observed'].to_numpy())
    cos_theta_S = np.sqrt(1 - df['active_spin'].to_numpy()**2)
    
    A = v_hat_x * np.cos(phi) + v_hat_z * np.sin(phi)
    B = v_hat_y
    C = cos_theta_S
    R = np.sqrt(A**2 + B**2)
    
    X = np.arctan2(B, A)
    Theta = np.arcsin(C / R) - X
    
    release_spin_rate = df['release_spin_rate'].to_numpy()
    
    # Calculate omega components
    omega_x = release_spin_rate * np.sin(Theta) * np.cos(phi)
    
    # Handle left/right handed pitchers differently for omega_y
    omega_y = np.where(
        df['p_throws'].to_numpy() == 'L',
        -release_spin_rate * np.cos(Theta),
        release_spin_rate * np.cos(Theta)
    )
    
    omega_z = release_spin_rate * np.sin(Theta) * np.sin(phi)
    
    # Calculate spin axis angles
    spin_axis_theta = np.degrees(np.arctan2(omega_y, np.sqrt(omega_x**2 + omega_z**2)))
    spin_axis_phi = np.degrees(np.arctan2(omega_z, omega_x))
    
    # Create result dataframe
    result = pd.DataFrame({
        'omega_x': omega_x,
        'omega_y': omega_y,
        'omega_z': omega_z,
        'spin_axis_theta': spin_axis_theta,
        'spin_axis_phi': spin_axis_phi
    })
    
    return result